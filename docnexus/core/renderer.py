from typing import List, Callable
import markdown
import re
import pymdownx.superfences

# Baseline/standard rendering: just Markdown -> HTML with extensions

def render_baseline(md_text: str) -> str:
    # 1. Remove [TOC] marker to prevents markdown extension from injecting it into body
    # (We render TOC separately in the template)
    md_text = re.sub(r'^\[TOC\]$', '', md_text, flags=re.MULTILINE | re.IGNORECASE)

    # 2. Remove legacy TOC placeholders (if any)
    # Replaces entire comment block with empty string
    md_text = re.sub(r'<!--TOC_PLACEHOLDER_START-->.*?<!--TOC_PLACEHOLDER_END-->', '', md_text, flags=re.DOTALL)
    
    # Render markdown to HTML
    md_instance = markdown.Markdown(
        extensions=[
            'fenced_code',
            'tables',
            'nl2br',
            'sane_lists',
            'codehilite',
            'toc',
            'extra',
            'attr_list',
            'def_list',
            'abbr',
            'footnotes',
            'md_in_html',
            'admonition',
            'pymdownx.arithmatex',
            'pymdownx.betterem',
            'pymdownx.caret',
            'pymdownx.mark',
            'pymdownx.tilde',
            'pymdownx.details',
            'pymdownx.highlight',
            'pymdownx.inlinehilite',
            'pymdownx.keys',
            'pymdownx.smartsymbols',
            'pymdownx.snippets',
            'pymdownx.superfences',
            'pymdownx.tabbed',
            'pymdownx.tasklist',
            'pymdownx.magiclink',
        ],
        extension_configs={
            "pymdownx.superfences": {
                "custom_fences": [
                    {
                        'name': 'mermaid',
                        'class': 'mermaid',
                        'format': pymdownx.superfences.fence_div_format
                    }
                ]
            }
        }
    )
    
    html_output = md_instance.convert(md_text)
    
    # Return both HTML (clean of TOC) and the TOC generated by python-markdown
    return html_output, md_instance.toc


def run_pipeline(md_text: str, steps: List[Callable[[str], str]]) -> str:
    out = md_text
    for fn in steps:
        out = fn(out)
    return out
